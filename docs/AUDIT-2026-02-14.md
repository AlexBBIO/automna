# BYOK Pivot Production Audit — 2026-02-14

## Critical Issues (Must Fix Before Launch)

### C1: Proxy mode machines get BYOK_MODE=false but no ANTHROPIC_API_KEY for LLM
**File:** `provision/route.ts` line ~280
**Problem:** When `isProxyMode=true`, the machine env sets `ANTHROPIC_API_KEY: gatewayToken` and `ANTHROPIC_BASE_URL` pointing to the proxy. However, the entrypoint script only checks `BYOK_MODE` to decide LLM routing. If `BYOK_MODE` is not `"true"`, it sets `ANTHROPIC_BASE_URL` to the proxy URL — but the **config merge script** also rewrites model refs to `automna/claude-opus-4-5` for legacy mode. This means LLM calls go through the `automna` provider in clawdbot.json, which uses the proxy URL + gatewayToken. **This should actually work**, but there's a subtle issue: the rate limiter checks `byokProvider === 'proxy'` and requires a positive credit balance. New proxy users only get 5K starter credits. At ~500 credits per message, that's ~10 messages before hard block with no obvious way to buy more from the chat UI.

**Impact:** Proxy users will hit a wall very quickly. The 5K bonus is too small for any meaningful usage.
**Fix:** Either increase starter bonus to 25K+ or add a prominent "buy credits" CTA in the chat when blocked.

### C2: Auto-refill balance update is NOT atomic — race condition
**File:** `auto-refill.ts` line ~95
```ts
balance: bal.balance + pack.credits, // OK to not be atomic here — this is the only writer after lock
```
**Problem:** The comment claims this is the only writer, but **the LLM proxy deducts credits concurrently**. If a request deducts credits between the `bal` read and this write, credits are overwritten (not added atomically). The `refillsInFlight` Set only prevents concurrent refills, not concurrent deductions.
**Impact:** Credits could be lost or gained incorrectly under load.
**Fix:** Use `sql\`balance + ${pack.credits}\`` for atomic update, same pattern used in the webhook handler.

### C3: Credit purchase webhook doesn't store stripeCustomerId in Clerk
**File:** `webhooks/stripe/route.ts` — `checkout.session.completed` for credit purchases
**Problem:** When a proxy user's first Stripe interaction is a credit purchase (not a subscription), the webhook adds credits but never stores `stripeCustomerId` in Clerk metadata. The credit purchase flow in `credits/purchase/route.ts` creates a Stripe customer but only returns the checkout URL — it doesn't update Clerk. If the user later tries to subscribe, a **new** Stripe customer may be created.
**Impact:** Duplicate Stripe customers, split payment history.
**Fix:** After creating a customer in `credits/purchase/route.ts`, update Clerk metadata with the customer ID.

### C4: Downgrade via `/api/upgrade` doesn't actually schedule for period end
**File:** `upgrade/route.ts` line ~130
**Problem:** For downgrades, the code sets `proration_behavior: 'none'` but doesn't use `billing_cycle_anchor` or schedule the change for period end. It immediately updates the subscription item to the new price. With `proration_behavior: 'none'`, Stripe won't charge/credit the difference, but the **plan change is immediate** — the user loses their higher tier features right away.
The `effectivePlan` grace period in the webhook partially mitigates this for rate limits, but the machine sleep config uses the **new** plan immediately for non-downgrade paths. For downgrades, sleep config update is skipped (good), but the `machines.plan` column IS updated immediately via `updateMachinePlan`.
**Impact:** User pays for the rest of their pro cycle but immediately gets downgraded plan limits in some paths.
**Fix:** Use Stripe's `schedule` API or `cancel_at_period_end` + new subscription, OR ensure all rate limit/feature checks use `effectivePlan` consistently.

## Important Issues (Should Fix Soon)

### I1: `refillsInFlight` Set is in-memory — doesn't survive serverless cold starts
**File:** `auto-refill.ts`
**Problem:** Vercel serverless functions are ephemeral. The `refillsInFlight` Set resets on every cold start. Two concurrent requests on different instances could both trigger refills.
**Fix:** Use a DB-level lock or `UPDATE ... WHERE balance < threshold AND auto_refill_flag = 0` pattern.

### I2: Stripe webhook doesn't handle `customer.subscription.updated` clerkUserId lookup correctly
**File:** `webhooks/stripe/route.ts` — `customer.subscription.updated`
**Problem:** It looks up `clerkUserId` from `customer.metadata.clerkUserId`, but the customer metadata is only set when the customer is created in `/api/checkout`. If the customer was created in `/api/credits/purchase` (which also creates customers), it **does** set `clerkUserId` in metadata — OK. But if the customer was created by Stripe directly (e.g., Stripe dashboard), there's no `clerkUserId`. The webhook silently does nothing.
**Impact:** Manual Stripe operations won't sync to Clerk/DB. Low risk but worth noting.

### I3: `BYOK_MODE` env var is a string — ensure no truthy/falsy confusion
**File:** `entrypoint.sh` checks `"${BYOK_MODE}" = "true"` (correct shell comparison)
**File:** `provision/route.ts` only sets `BYOK_MODE: "true"` for BYOK users (good — not set at all for proxy)
**Status:** Actually OK on inspection. The entrypoint defaults to legacy mode if BYOK_MODE is unset.

### I4: Dashboard BYOK gate may redirect loop for edge cases
**File:** `dashboard/page.tsx` — initializeGateway
**Problem:** The BYOK gate checks `/api/user/byok` and redirects to `/setup/connect` if `!byokData.enabled && byokData.type !== 'proxy'`. But `byokData.type` could be `null` for a brand-new user who just subscribed but hasn't visited `/setup/connect` yet. The redirect to `/setup/connect` is correct behavior, but if the user navigates back to `/dashboard` without choosing, they'll be redirected again. This is **intended** (gate behavior), not a loop — but the UX could be confusing.
**Impact:** Minor UX friction. Users might feel stuck.
**Fix:** Add a dismissible explanation on the connect page.

### I5: Checkout success URL goes to `/setup/connect`, not `/dashboard`
**File:** `checkout/route.ts` — `success_url`
**Status:** This is actually correct for the BYOK flow — after subscribing, users should choose their connection method. Good.

### I6: Proxy user revert from BYOK sets `ANTHROPIC_API_KEY` to... nothing
**File:** `byok/route.ts` — `revertMachineToProxyMode()`
**Problem:** When reverting to proxy mode, the code sets `ANTHROPIC_BASE_URL` to the proxy URL but doesn't set `ANTHROPIC_API_KEY` to `gatewayToken`. The env just doesn't have `ANTHROPIC_API_KEY` after revert.
**Impact:** The entrypoint config merge handles this via the `automna` provider in clawdbot.json (which uses `gatewayToken` as apiKey). So direct `ANTHROPIC_API_KEY` may not be needed if the config is correct. But if any code path reads `ANTHROPIC_API_KEY` directly, it will fail.
**Fix:** Set `ANTHROPIC_API_KEY` to gatewayToken in the revert path (read from machine env).

### I7: `kill -USR1` to restart gateway may not work
**File:** `byok/route.ts` — `pushCredentialToMachine()`
**Problem:** `kill -USR1 $(pgrep -f openclaw-gateway || pgrep -f entry.js || echo 1)` — if no process matches, it sends USR1 to PID 1 (init/entrypoint). USR1 to a shell script is undefined behavior.
**Impact:** Gateway may not pick up new credentials until machine restart.
**Fix:** Use a more reliable restart mechanism, or document that credentials apply on next restart.

## Minor Issues (Nice to Have)

### M1: UsageBanner has unused `usage` prop
**File:** `UsageBanner.tsx` — receives `usage` prop but never uses it (fetches its own data)

### M2: Pricing page uses `process.env.NEXT_PUBLIC_*` at module level
**File:** `pricing/page.tsx` — `plans` array reads env vars at module scope. In Next.js client components, `NEXT_PUBLIC_` vars are inlined at build time, so this works. But if the env vars aren't set at build time, `priceId` will be `undefined`, and the checkout button will be disabled silently.

### M3: Credit transactions `createdAt` cast
**File:** `credits/route.ts` — `new Date(t.createdAt as unknown as number)` — fragile cast. If schema returns a Date object, this double-converts.

### M4: No input validation on auto-refill POST settings
**File:** `credits/route.ts` — `autoRefillAmountCents` is clamped to min 500 ($5) but no max. User could set it to $999,999.

### M5: Missing rate-limit file at expected path
Expected: `api/_lib/rate-limit.ts`, Actual: `api/llm/_lib/rate-limit.ts`. Not a bug (imports work), just confusing.

## Flow-by-Flow Analysis

### Flow 1: New BYOK User (Claude OAuth) ✅ PASS
Sign up → Pricing → Checkout → Stripe → webhook sets Clerk metadata → redirect to `/setup/connect` → Choose Claude → Paste token → POST `/api/user/byok` (stores encrypted, updates Clerk metadata) → redirect to `/dashboard` → BYOK gate passes → fetch gateway → needs provisioning → POST `/api/user/provision` → creates app/volume/machine with BYOK env → pushes auth-profiles.json → poll status → WebSocket ready → chat works.
**Notes:** Setup tokens (sk-ant-oat) skip validation (correct — they can't call /v1/messages). If machine creation is slow, the WebSocket probe loop handles it gracefully.

### Flow 2: New BYOK User (API Key) ✅ PASS
Same as Flow 1 but API key is validated against Anthropic API before storing. Clean flow.

### Flow 3: New Proxy User ⚠️ PARTIAL PASS
Sign up → Pricing → Checkout → `/setup/connect` → "Bill me as I go" → POST `/api/user/byok/proxy` (sets byokChoice='proxy', grants 5K bonus credits) → redirect to `/dashboard` → BYOK gate: `byokData.type === 'proxy'` passes → provision → machine created with proxy env vars (ANTHROPIC_BASE_URL=proxy, ANTHROPIC_API_KEY=gatewayToken) → chat starts.
**Issue:** 5K credits is extremely limited. User will hit zero quickly, then see a hard block from the rate limiter. The UsageBanner shows credit balance and a "Buy Credits" link, but the user may not understand why chat stopped. See **C1**.

### Flow 4: Legacy User Migration ✅ PASS
User sees migration banner on pricing page with "Keep my plan — just connect Claude" link → goes to `/setup/connect` → chooses connection method → POST `/api/user/byok` → `ensureMachineByokMode()` updates machine env (removes ANTHROPIC_BASE_URL, adds BYOK_MODE=true, pulls latest image, restarts) → pushes auth-profiles.json → user is BYOK.
**Notes:** Legacy users keep their old subscription price. The banner correctly shows old price and offers migration path.

### Flow 5: BYOK User Removes Credentials ✅ PASS
DELETE `/api/user/byok` → deletes secret → updates Clerk metadata to `byokChoice: 'proxy'` → updates machines table → `revertMachineToProxyMode()` (removes BYOK_MODE, restores proxy URL, deletes auth-profiles.json, restarts machine).
**Issue:** See **I6** — ANTHROPIC_API_KEY may not be set in reverted env. Should work via clawdbot.json config but is fragile.

### Flow 6: Plan Upgrade (Starter → Pro) ✅ PASS
POST `/api/upgrade` with new priceId → Stripe subscription update with proration → Clerk metadata updated → webhook fires `customer.subscription.updated` → updates machines.plan → clears effectivePlan → updates sleep config (pro = always-on) → provisions phone number.

### Flow 7: Plan Downgrade (Pro → Starter) ⚠️ PARTIAL PASS
POST `/api/upgrade` → immediate price change with `proration_behavior: 'none'` → webhook sets `effectivePlan` to old plan with period end timestamp → rate limiter respects effectivePlan.
**Issue:** See **C4** — the plan change is immediate in Stripe, not scheduled for period end. User stops paying pro price immediately but keeps pro limits until period end. This is backwards from the expected behavior (pay pro until period end, then downgrade).

### Flow 8: Cancellation ✅ PASS
Stripe subscription deleted → webhook sets plan to 'free', subscription_status to 'canceled' → updates machine plan → enables auto-stop/sleep → sends cancellation email.
**Notes:** Machine isn't destroyed, just sleeps. User can re-subscribe and their data persists. Good design.

### Flow 9: Credit Purchase ✅ PASS
POST `/api/user/credits/purchase` → creates Stripe checkout session (one-time payment) → Stripe checkout → webhook `checkout.session.completed` with `type: 'credit_purchase'` → atomically adds credits → creates transaction log.
**Issue:** See **C3** — stripeCustomerId may not persist in Clerk.

### Flow 10: Auto-Refill ⚠️ PARTIAL PASS
LLM proxy deducts credits → calls `checkAutoRefillBackground()` → checks balance < threshold → checks monthly cap → finds closest pack → charges default payment method → adds credits.
**Issues:** See **C2** (non-atomic balance update) and **I1** (in-memory lock on serverless). Also: if payment requires 3DS, it catches `authentication_required` and silently skips — user gets no notification that auto-refill failed.

### Flow 11: Zero Balance Proxy User ✅ PASS
Rate limiter checks `creditBalance <= 0` → returns 429 with "No credits remaining" → UsageBanner shows empty state with "Buy Credits" button.

### Flow 12: Provision Retry ✅ PASS
Dashboard sets `initStarted` ref → if error, shows "Try Again" button → `window.location.reload()` → ref resets → full flow re-runs. The `provisionStatus` table tracks state, and the provision route handles existing apps/machines gracefully (reuses if already_exists). Volume creation would fail if volume already exists — but the provision route only creates a volume if creating a new machine, not on retry of existing.
**Edge case:** If provision partially completed (app created, volume created, machine creation failed), retry will find the app exists, skip app creation, try to create a new volume (might fail with duplicate name), then try machine creation. The volume creation would throw and the whole provision would error. This is an existing issue, not specific to BYOK.

---

## Summary

**Ready for launch with caveats.** The BYOK flows (OAuth + API key) are solid. The proxy/credits flow works but has rough edges around balance management (C1, C2) and the downgrade flow has a billing inconsistency (C4). 

**Recommended launch plan:**
1. Fix C2 (atomic balance update) — quick fix, high risk if not done
2. Fix C1 (increase starter credits or improve UX) — impacts first impression
3. Fix C3 (persist stripeCustomerId) — prevents future billing headaches
4. Document C4 (downgrade behavior) — can ship as-is if documented, fix later
5. Ship BYOK flows (OAuth + API key) immediately
6. Ship proxy mode as "beta" or delay slightly for C1/C2 fixes
